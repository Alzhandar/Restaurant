## Система бронирования ресторана

Высоконагруженный backend‑сервис для бронирования столиков в ресторанах.

Проект реализует поиск ресторанов, управление столиками, бронирования, отзывы и рейтинги, фоновые задачи, кэширование. 

---

## Основной функционал

- **Пользователи и роли**: гость (`guest`), владелец ресторана (`restaurant_owner`), администратор (`admin`)
- **Рестораны и столики**: хранение и управление ресторанами, столиками, расписанием работы
- **Бронирования**: создание/изменение/отмена, проверка доступности столиков, статусы (pending/confirmed/…)
- **Отзывы и рейтинги**: оставление отзывов по завершённым бронированиям
- **Фоновые задачи**: email‑уведомления, напоминания, обработка no‑show, отчёты (Celery + Redis)
- **Кэширование**: Redis для кэша и сессий

---

## Архитектура

- **Входной трафик** идёт от клиентов (web / mobile) на **Nginx / load balancer**, который:
  - терминирует SSL
  - делает базовый rate limiting
  - балансирует нагрузку между несколькими экземплярами Django API
- **Django REST API** (несколько экземпляров):
  - реализует бизнес‑логику (рестораны, столики, бронирования, отзывы)
  - использует JWT‑аутентификацию (Simple JWT)
  - генерирует документацию OpenAPI через DRF Spectacular
  - статичен (не хранит сессию в памяти), что позволяет легко масштабировать по горизонтали
- **PostgreSQL** — основная реляционная БД:
  - хранит пользователей, рестораны, столики, бронирования, отзывы
  - за счёт транзакций и индексов обеспечивает консистентность и защиту от гонок при бронировании
- **Redis**:
  - кэширует тяжёлые запросы (доступные столики, списки ресторанов, рейтинги)
  - хранит сессии
  - выступает брокером для Celery
- **Celery** (через Redis как broker/result backend):
  - асинхронные задачи: отправка писем, напоминаний, пересчёт рейтингов, отчёты
  - отдельные worker’ы и планировщик (beat) для периодических заданий
- **Логирование**:
  - приложение пишет структурированные логи в файл и консоль 

Валидации:

- валидацию входных данных
- проверку доступности столика по дате/времени
- транзакции в БД 
- инвалидацию кэша Redis по ключам доступности столиков
- публикацию задания в очередь для отправки подтверждения и напоминаний

---

## Стэк технологий

[![Nginx][Nginx]][Nginx-url]
[![Django][Django]][Django-url]
[![Django REST Framework][DRF]][DRF-url]
[![Simple JWT][SimpleJWT]][SimpleJWT-url]
[![DRF Spectacular][Spectacular]][Spectacular-url]
[![PostgreSQL][Postgres]][Postgres-url]
[![Redis][Redis]][Redis-url]
[![Celery][Celery]][Celery-url]

---

## Запуск в Docker

### Разработка

**Требования:**
- Docker 24.0+
- Docker Compose 2.20+

```bash
# 1. Создать .env файл из примера (если его ещё нет)
cp .env.example .env.docker.dev

# 2. Отредактировать .env.docker.dev при необходимости

# 3. Собрать и запустить контейнеры (через Makefile)
make dev-up

# Или без Makefile:
docker-compose -f docker-compose.dev.yml up --build
```

После запуска dev‑окружения:

- **API / Swagger:** http://localhost:8000 и http://localhost:8000/api/docs/
- **Админка:** http://localhost:8000/admin/

Применение миграций и создание суперпользователя:

```bash
docker-compose -f docker-compose.dev.yml exec web python manage.py migrate
docker-compose -f docker-compose.dev.yml exec web python manage.py createsuperuser
```

---

### Продакшн

```bash
# 1. Создать .env для production
cp .env.example .env

# 2. ОБЯЗАТЕЛЬНО изменить:
#    - SECRET_KEY
#    - DB_PASSWORD
#    - ALLOWED_HOSTS
#    - DEBUG=False

# 3. Собрать и запустить
make prod-up

# Или вручную:
docker-compose up -d --build

# 4. Применить миграции и собрать статику
docker-compose exec web python manage.py migrate
docker-compose exec web python manage.py collectstatic --noinput
docker-compose exec web python manage.py createsuperuser
```
---

## API и документация

- **Swagger UI:** http://localhost:8000/api/docs/
- **ReDoc:** http://localhost:8000/api/redoc/
- **OpenAPI JSON:** http://localhost:8000/api/schema/
- Подробное текстовое описание эндпоинтов: `API_DOCUMENTATION.md`

Основные группы API:

- `users` — аутентификация, регистрация, управление профилем и пользователями
- `restaurants` — рестораны, столики, доступность столиков, поиск
- `reservations` — CRUD бронирований, смена статусов, выборка по времени/статусу
- `reviews` — CRUD отзывов, агрегированные рейтинги, проверки возможности оставить отзыв

---

## Еще:

- **Обзор архитектуры и highload‑решений:** `docs/PROJECT_OVERVIEW.md`
- **Docker (расширенно):** `docs/DOCKER_SETUP.md`, `docs/DOCKER_DEPLOYMENT.md`
- **Переменные окружения:** `docs/ENVIRONMENT_VARIABLES.md`
- **Прогресс/чек‑лист по заданию курса:** `PROGRESS.md`

---

## Ответы на вопросы:

1.Как выбор структуры базы данных (SQL или NoSQL) влияет на дизайн CRUD API?

SQL — строгая структура. Все данные хранятся в таблицах. У каждой таблицы заранее заданы столбцы (id, name, email и т.д.). Нельзя просто так добавить новое поле в одну запись — нужно менять всю таблицу. Как это влияет на API? 1) Формат данных фиксированный. 2) Каждый POST, PUT или PATCH должен строго соответствовать полям таблицы. 3) Если чего-то не хватает — будет ошибка.
Тем временем у NoSQL гибкая структура. Данные хранятся в виде документов (например, JSON). У разных записей могут быть разные поля. Можно добавлять новые поля только в отдельных документах, без изменения всей базы. Как это влияет на API? 1) API может принимать разный формат. 2) У одних записей есть поле, у других — нет. 3) Меньше ограничений при создании и изменении данных.

2.Какие проблемы могут возникнуть при массовых обновлениях данных через API?

Когда нужно обновить много записей за раз, может произойти перегрузка сервера, долго выполняться или таймаут, также не исключаются конфликты (данные могут изменяться другими), частичное обновление (часть изменилась, часть — нет) или ошибки при повторном запросе (дубли и сбои)

3.Почему важно использовать правильные HTTP-методы (GET, POST, PUT, DELETE), а не только POST?

Тип HTTP-запроса (также называемый HTTP-метод) указывает серверу на то, какое действие мы хотим произвести с ресурсом. Изначально (в начале 90-х) предполагалось, что клиент может хотеть от ресурса только одно — получить его, однако сейчас по протоколу HTTP можно создавать посты, редактировать профиль, удалять сообщения и многое другое. И эти действия сложно объединить термином «получение».
Для разграничения действий с ресурсами на уровне HTTP-методов были придуманы. GET — получение ресурса, POST — создание ресурса, PUT — обновление ресурса, DELETE — удаление ресурса
Если всё делать через POST, то нельзя будет кешировать, не будет непонятно другим разработчикам, могут возникнуть проблемы с браузерами, прокси и безопасностью

4.Какие уязвимости могут возникнуть при хранении JWT на клиентской стороне?

Если токен лежит в localStorage или sessionStorage, злоумышленник может вставить JavaScript-код на страницу и украсть токен.
Если JWT хранится в cookie без защиты, браузер автоматически отправит его, даже если запрос сделан с чужого сайта.

5.В каких случаях стоит ограничивать время жизни JWT, и какие проблемы это создаёт для UX?

В таких случаях как: 1) Если данные чувствительные (банкинг, медицина, госуслуги), 2) Если люди работают с чужих устройств, 3) Если высокий риск взлома или утечки токена, 4) Если это админ-панель или корпоративная система
Проблемы же, которые возникают при таком ограничении являются : 1) Пользователь внезапно “вылетает” из аккаунта, 2) Прерывается работа при заполнении формы, 3) Нужно часто логиниться заново, 4) WebSocket/SPA/мобильные приложения перестают работать без обновления токена
Чтобы уменьшить дискомфорт — делают refresh-токены

6.Как логирование помогает в расследовании инцидентов безопасности?

Благодаря логированию можно понять - кто и когда совершал действия. Кто логинился, ошибки авторизации, попытки подбора пароля. Также найти подозрительные запросы. Например: массовые запросы в API, взлом через SQL-injection / XSS, подмена токенов. Можно отследить IP, устройство, время, географию. Для того, чтобы понять — это пользователь или злоумышленник. Немаловажным является и то, что можно восстановить ход событий, что же произошло до и после взлома системы. К примеру: как вошли, что изменили и какие токены использовали. Логирование помогает доказать инцидент (юридически и технически)
Без логов же ситуация ухудшается. Невозможно понять, как украли токен. Нельзя узнать, что уже успели сделать. Трудно доказать, что атака была

7.В чём разница между горизонтальным и вертикальным масштабированием, и как это связано с кэшированием?

Вертикальным называется масштабирование при котором для увеличения производительности в уже имеющееся оборудование добавляют новые процессоры, диски, память. Такой подход применяется в случаях, когда лимит производительности элементов инфраструктуры исчерпан.
Преимущества: 
1) если компании не хватает ресурсов имеющегося оборудования, его компоненты можно заменить более мощными; 
2) увеличение производительности каждого компонента в рамках одного узла повышает производительность IT-инфраструктуры в целом.

Недостатки: 
1) ограничения в увеличении производительности.

Суть горизонтального масштабирования — в добавлении новых узлов в IT-инфраструктуру. Вместо того, чтобы увеличивать мощность отдельных компонентов узла, компания добавляет новые серверы. С каждым дополнительным узлом нагрузка перераспределяться между всеми узлами.

Преимущества: 
1) позволяет использовать недорогое оборудование, которое обеспечивает достаточное количество мощностей для рабочих нагрузок; 
2) необходимость переносить инфраструктуру отсутствует; 
3) компания может организовать работу без простоев благодаря тому, что экземпляры ПО работают на нескольких узлах IT-инфраструктуры. 
4) при необходимости мигрировать виртуальные машины в другую инфраструктуру, это можно сделать, не останавливая работу;

Как это связано с кэшированием? Экземпляр с одним кэшем может обрабатывать миллионы запросов в секунду, предлагая при этом недостижимый для баз данных уровень пропускной способности и масштабируемости. А при горизонтальном или вертикальном масштабировании, он обеспечивает гибкость приложений и хранилищ данных, чтобы пользователи могли одновременно получать доступ к одним и тем же файлам без увеличения нагрузки на серверные базы данных. А если работа приложения характеризуется частыми пиками и высокой нагрузкой на пропускную способность, кэши в памяти помогут устранить задержку.

8.Какой риск несут фоновые задачи при сбое очереди сообщений? 

Если сообщение постоянно вызывает ошибку в потребителе, это блокирует задачу, очередь и, в конечном итоге, само приложение, когда очередь становится полной. Поэтому важно обнаружить и удалить подозрительные сообщения из очереди.

9.Почему важно учитывать идемпотентность задач при их повторном выполнении? 

Идемпотентное исполнение повторного запроса предотвращает избыточные вычисления, связанные с повторной обработкой запроса, что способствует повышению эффективности и отзывчивости системы.
Если все внешние системы, с которыми взаимодействует сервис, обладают свойством идемпотентности, то дополнительный контроль на стороне API сервиса может быть излишним. В таких случаях запросы к внешним системам могут быть повторены без опасений, поскольку они обеспечивают гарантию однократного изменения состояния системы.

10.Что сложнее поддерживать в большой системе: код или документацию? Почему? 

Основное различие между этими двумя задачами заключается в интерфейсе коммуникации. В случае написания кода мы имеем дело с описанными процедурами, которые дают более или менее предсказуемые результаты. Машины не будут спорить и жаловаться, они просто не позволят вам сделать то, чего они не умеют. И некого будет винить, если решение задачи заведет в тупик. 
При создании документации задача становится сложнее в плане определенности, ведь мы имеем дело с людьми. А уникального способа передачи знаний от одного разума к другому пока просто нет. Методы существуют, и задача более чем решаема. Но чтобы добиться успеха в этом деле от человека требуется другие черты, такие как сочувствие и понимание.
В заключении, могу сказать, что документация сложнее поддерживать в большой системе, чем код.

11.Какие плюсы и минусы у ручного написания README по сравнению с автогенерацией документации? 

Сначала поговорим о автогенераций документации. Из плюсов можно выделить то, что такая документация собирается из исходного кода. В итоге, гораздо меньше риска, что она устареет, можно получить документацию даже для огромного проекта за секунды. А сами автогенераторы предлагают понятную структуру. Из минусов же можно сказать, что они описывают “что” есть, но не “как” и “зачем” этим пользоваться, в них нет души может кто-то сказать, иногда приходиться переписывать комментарии в коде, чтобы автогенератор не выдавал мусор. 
Что касается ручного написания, то тут у нас есть свобода действий. Можно писать в любом стиле, добавлять примеры, структуры и обяснения, которые невозможно вывести автоматически. Хороший README отвечает реальным вопросам разработчиков: как установить, как запустить, какие типичные проблемы. Ручное README может быть дружелюбным. Минусами, как не странно, является долгое написание, т.е потраченного времени больше, нужно постоянно обновлять его вместе с кодом, а то начнет устаревать. Также можно забыть описать важные моменты или написать слишком субъективно. В больших проектах трудно вручную поддерживать в актуальном состоянии все детали.

12.Как документация помогает при онбординге новых разработчиков в команду? 

Подробно описанные задачи и документация делают процесс онбординга нового сотрудника гораздо проще. Новый член команды сможет быстро вникнуть в проект и эффективно работать с ним дальше. Предоставление новичку быстрый доступ к информации об архитектуре системы, инструментах и процессах, приводит к ускорению его адаптацию и сокращает время, необходимое для начала самостоятельной работы. Она снижает количество вопросов к коллегам, помогает быстрее понять задачи, улучшает качество кода и облегчает последующую поддержку проекта. 

Reference: 
1) https://habr.com
2) https://learn.microsoft.com
3) https://ru.vstack.com

[Nginx]: https://img.shields.io/badge/Nginx-009639?style=for-the-badge&logo=nginx&logoColor=white
[Nginx-url]: https://nginx.org/

[Django]: https://img.shields.io/badge/Django-092E20?style=for-the-badge&logo=django&logoColor=white
[Django-url]: https://www.djangoproject.com/

[DRF]: https://img.shields.io/badge/DRF-ff1709?style=for-the-badge&logo=django&logoColor=white
[DRF-url]: https://www.django-rest-framework.org/

[SimpleJWT]: https://img.shields.io/badge/SimpleJWT-blue?style=for-the-badge
[SimpleJWT-url]: https://github.com/jazzband/djangorestframework-simplejwt

[Spectacular]: https://img.shields.io/badge/DRF_Spectacular-4B8BBE?style=for-the-badge
[Spectacular-url]: https://drf-spectacular.readthedocs.io/

[Postgres]: https://img.shields.io/badge/PostgreSQL-316192?style=for-the-badge&logo=postgresql&logoColor=white
[Postgres-url]: https://www.postgresql.org/

[Redis]: https://img.shields.io/badge/Redis-DC382D?style=for-the-badge&logo=redis&logoColor=white
[Redis-url]: https://redis.io/

[Celery]: https://img.shields.io/badge/Celery-37814A?style=for-the-badge&logo=celery&logoColor=white
[Celery-url]: https://docs.celeryq.dev/







